{
  "id": "surfacer",
  "titleShort": "Surfacer",
  "titleLong": "Surface: A procedural pathfinding 2D-platformer framework for Godot.",
  "urls": {
    "demo": "https://levi.dev/surfacer",
    "github": "https://github.com/levilindsey/surfacer"
  },
  "jobTitle": "",
  "location": "",
  "date": {
    "start": "2/2019",
    "end": "2020"
  },
  "categories": [
    "side-project",
    "frontend",
    "animation",
    "app",
    "godot",
    "gdscript",
    "game",
    "library"
  ],
  "images": [],
  "videos": [],
  "content": "_**NOTE:** This framework and demo game are still works-in-progress._\r\n\r\n_\"Surfacer\": Like a platformer, but with walking, climbing, and jumping on all surfaces!_\r\n\r\n**tl;dr**: Surfacer works by **pre-parsing** a level into a **\"platform graph\"**. The **nodes** are represented by points along the different surfaces in the level (floors, walls, and ceilings). The **edges** are represented by possible movement trajectories between points along surfaces. There are different types of edges for different types of movement (e.g., jumping from a floor to a floor, falling from a wall, walking along a floor). At run time, **[A* search](https:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm)** is used to calculate a path to a given destination.\r\n\r\nSome features include:\r\n-   Walking on floors, climbing on walls, climbing on ceilings, jumping and falling from anywhere.\r\n-   [Variable-height jump and fast-fall](https:\/\/kotaku.com\/the-mechanics-behind-satisfying-2d-jumping-1761940693).\r\n-   Adjusting movement trajectories around intermediate surfaces (such as jumping over a wall or under an overhang).\r\n-   Configurable movement parameters on a per-player basis (e.g., horizontal acceleration, jump power, gravity, collision boundary shape and size, which types of edge movement are allowed).\r\n-   Level creation using Godot's standard pattern with a [TileMap in the 2D scene editor](https:\/\/docs.godotengine.org\/en\/3.2\/tutorials\/2d\/using_tilemaps.html).\r\n-   Preparsing the level into a platform graph, and using A* search for efficient path-finding at runtime.\r\n\r\n## Buy why?\r\n\r\nBecause there aren't many other good tools out there for intelligent pathfinding in a platformer.\r\n\r\nThe vast majority of platformers use pretty simple computer-player AI for movement--for example:\r\n-   Walk to edge, turn around, repeat.\r\n-   Jump continuously, moving forward.\r\n-   Move with a regular bounce or surface-following pattern.\r\n-   Move horizontally toward the human player, \"floating\" vertically as needed in order to move around obstacles and platforms.\r\n\r\nMost examples of more sophisticated AI pathfinding behavior are usually still pretty limited. One common technique uses machine-learning and is trained by hundreds to thousands of human-generated jumps on an explicit pre-fabricated level. This makes level-generation difficult and is not flexible to dynamic platform creation\/movement.\r\n\r\nThere are two key reasons why good path-finding AI isn't really used in platformers:\r\n1.  It's hard to implement right; there is a lot of math involved, and there are a lot of different edge cases to account for.\r\n2.  Dumb AI is usually plenty effective on its own to create compelling gameplay. The user often doesn't really notice or care how simple the behavior is.\r\n\r\nBut there are use-cases for which we really benefit from an AI that can accurately immitate the same movement mechanics of the player. One example is if we want to have a flexible game mode in which a computer player can swap in for a human player depending on how many humans are present.\r\n\r\n## Platformer AI\r\n\r\n### The platform graph: Pre-parsing the world\r\n\r\nSurfacer depends on the level being represented as a [`TileMap`](https:\/\/docs.godotengine.org\/en\/3.2\/classes\/class_tilemap.html#class-tilemap).\r\n\r\nIn order for our AI to traverse our world, we first need to parse the world into a platform graph. We do this up-front, when the level is loaded, so that we can efficiently search the graph at run time. Dynamic updates to the graph can be performed at runtime, but these could be expensive if not done with care.\r\n\r\nThe nodes of this graph correspond to positions along distinct surfaces. Since our players can walk on floors, climb on walls, and climb on ceilings, we store floor, wall, and ceiling surfaces.\r\n\r\nThe edges of this graph correspond to a type of movement that the player could perform in order to move from one position on a surface node to another.\r\n-   These edges are directional, since the player may be able to move from A to B but not from B to A.\r\n-   The ends of an edge could be along the same surface or on different surfaces (e.g., for climbing up a wall vs jumping from a floor).\r\n-   There could be multiple edges between a single pair of nodes, since there could be multiple types of movement that could get the player from the one to the other.\r\n-   These edges are specific to a given player type. If we need to consider a different player that has different movement parameters, then we need to calculate a separate platform graph for that player.\r\n\r\nTODO: diagrams:\r\n- show a screenshot with just surfaces highlighted and cell indices rendered\r\n- show a screenshot with just edge trajectories rendered\r\n\r\n### Nodes: Parsing a Godot `TileMap` into surfaces\r\n\r\n**NOTE**: The following algorithm assumes that the given `TileMap` only uses tiles with convex collision boundaries.\r\n\r\n#### Parse individual tiles into their constituent surfaces\r\n\r\n-   Map each `TileMap` cell into a polyline that corresponds to the top-side\/floor portion of its collision polygon.\r\n    -   Calculate whether the collision polygon's vertices are specified in a clockwise order.\r\n        -   Use this to determine the iteration step size.\r\n            -   `step_size = 1` if clockwise; `step_size = -1` if counter-clockwise.\r\n        -   Regardless of whether the vertices are specified in a clockwise order, we will iterate over them in clockwise order.\r\n    -   Find both the leftmost and rightmost vertices.\r\n    -   Start with the leftmost vertex.\r\n        -   If there is a wall segment on the left side of the polygon, then this vertex is part of it.\r\n        -   If there is no wall segment on the left side of the polygon, then this vertex must be the cusp between a preceding bottom-side\/ceiling segment and a following top-side\/floor segment (i.e., the previous segment is underneath the next segment).\r\n            -   Even if there is no segment along one side, we store a surface for that side; this surface is only represented by a single point.\r\n    -   Iterate over the following vertices until we find a non-wall segment (this could be the first segment, the one connecting to the leftmost vertex).\r\n        -   Wall segments are distinguished from floor\/ceiling segments according to their angle. This is configurable, but typically, a segment up to 45-degrees is a floor\/ceiling and a segment steeper than 45-degrees is a wall.\r\n    -   This non-wall segment must be the start of the top-side\/floor polyline.\r\n    -   Iterate, adding segments to the result polyline, until we find either a wall segment or the rightmost vertex.\r\n    -   We then also save a mapping from a `TileMap` cell index to each of the different surfaces we've calculated as existing in that cell.\r\n-   Repeat the above process for the right-side, left-side, and bottom-side surfaces.\r\n\r\nTODO: diagrams:\r\n- showing surfaces with cell indices\r\n\r\n#### Remove internal surfaces\r\n\r\n**NOTE**: This will only detect internal surface segments that are equivalent with another internal segment. But for grid-based tiling systems, this can often be enough.\r\n\r\n-   Check for pairs of floor+ceiling segments or left-wall+right-wall segments, such that both segments share the same vertices.\r\n-   Remove both segments in these pairs.\r\n\r\nTODO: diagrams:\r\n- eliminating internal surfaces\r\n\r\n#### Merge any connecting surfaces\r\n\r\n-   Iterate across each floor surface A.\r\n-   Nested iterate across each other floor surface B.\r\n    -   Ideally, we should be using a spatial data structure that allows us to only consider nearby surfaces during this nested iteration (such as an R-Tree).\r\n-   Check whether A and B form a \"continuous\" surface.\r\n    -   A and B are both polylines that only have two end points.\r\n    -   Just check whether either endpoint of A equals either endpoint of B.\r\n        -   Actually, our original `TileMap` parsing results in every surface polyline being stored in clockwise order, so we only need to compare the end of A with the start of B and the start of A with the end of B.\r\n-   If they do:\r\n    -   Merge B into A.\r\n    -   Optionally, remove any newly created redundant internal colinear points.\r\n    -   Remove B from the surface collection.\r\n-   Repeat the iteration until no merges were performed.\r\n\r\nTODO: diagrams:\r\n- merging connected surfaces\r\n\r\n#### Record adjacent neighbor surfaces\r\n\r\n-   Every surface should have both adjacent clockwise and counter-clockwise neighbor surfaces.\r\n-   Use a similar process as above for finding surfaces with matching end positions.\r\n\r\nTODO: diagrams:\r\n- detecting neighbor surfaces\r\n\r\n### Edges: Calculating jump movement trajectories\r\n\r\n**tl;dr**: The Surfacer framework uses a procedural approach to calculate trajectories for movement between surfaces. The algorithms used rely heavily on the classic [one-dimensional equations of motion for constant acceleration](https:\/\/physics.info\/motion-equations\/). These trajectories are calculated to match to the same abilities and limitations that are exhibited by corresponding human-controlled movement. After the trajectory for an edge is calculated, it is translated into a simple instruction\/input-key start\/end sequence that should reproduce the calculated trajectory.\r\n\r\n**NOTE**: A machine-learning-based approach would probably be a good alternate way to solve this general problem. However, one perk of a procedural approach is that it's relatively easy to understand how it works and to modify it to perform better for any given edge-case (and there are a _ton_ of edge-cases).\r\n\r\n#### The high-level steps\r\n\r\n-   Determine how high we need to jump in order to reach the destination.\r\n-   If the destination is out of reach (vertically or horizontally), ignore it.\r\n-   Calculate how long it will take for vertical motion to reach the destination from the origin.\r\n-   We will define the movement trajectory as a combination of two independent components: a \"vertical step\" and a \"horizontal step\". The vertical step is based primarily on on the jump duration calculated above.\r\n-   Calculate the horizontal step that would reach the destination displacement over the given duration.\r\n-   Check for any unexpected collisions along the trajectory represented by the vertical and horizontal steps.\r\n    -   If there is an intermediate surface that the player would collide with, we need to try adjusting the jump trajectory to go around either side of the colliding surface.\r\n        -   We call these points that movement must go through in order to avoid collisions, \"constraints\".\r\n        -   Recursively check whether the jump is valid to and from either side of the colliding surface.\r\n        -   If we can't reach the destination when moving around the colliding surface, then try backtracking and consider whether a higher jump height from the start would get us there.\r\n    -   If there is no intermediate collision, then we can calculate the ultimate edge movement instructions for playback based on the vertical and horizontal steps we've calculated.\r\n\r\n#### Some important aspects\r\n\r\n-   We treat horizontal and vertical motion as independent to each other. This greatly simplifies our calculations.\r\n    -   We calculate the necessary jump duration--and from that the vertical component of motion--up-front, and use this to determine times for each potential step and constraint of the motion. Knowing these times up-front makes the horizontal min\/max calculations easier.\r\n-   We have a broad-phase check to quickly eliminate possible surfaces that are obviously out of reach.\r\n    -   This primarily looks at the horizontal and vertical distance from the origin to the destination.\r\n-   For each pair of surfaces, we consider three potential points as our jump-off and land positions along each surface: the near end, the far end, and the closest point along the surface.\r\n    -   We check for valid edge movement instructions along each potential jump\/land position pair between the two surfaces, and we save _only the first_ valid edge that we find.\r\n        -   We could instead save _all_ valid edges that we find (up to nine edges for each directed pair of surfaces), but calculating extra edges is very expensive, and we can usually assume that an edge between closer points will be better to use anyway.\r\n    -   We only consider the closest point if it is distint from near and far ends (and for degenerate surfaces of only one vertex, we skip the far end).\r\n\r\nFIXME: LEFT OFF HERE: ----------------- Maybe move some of the lower-down stuff into this laundry list?\r\n\r\nTODO: Include a screenshot of a collision that clips the corner of the wall when trying to jump to the above floor--a very common scenario.\r\n\r\n#### Calculating the total jump duration (and the vertical step for the edge)\r\n\r\n-   At the start of each edge-calculation traversal, we calculate the minimum total time needed to reach the destination.\r\n    -   If the destination is above, this might be the time needed to rise that far in the jump.\r\n    -   If the destination is below, this might be the time needed to fall that far (still taking into account any initial upward jump-off velocity).\r\n    -   If the destination is far away horizontally, this might be the time needed to move that far horizontally (taking into account the horizontal movement acceleration and max speed).\r\n    -   The greatest of these three possibilities is the minimum required total duration of the jump.\r\n-   The minimum peak jump height can be determined from this total duration.\r\n-   All of this takes into account our variable-height jump mechanic and the difference in slow-ascent and fast-fall gravities.\r\n    -   With our variable-height jump mechanic, there is a greater acceleration of gravity when the player either is moving downward or has released the jump button.\r\n    -   If the player releases the jump button before reaching the maximum peak of the jump, then their current velocity will continue pushing them upward, but with the new stronger gravity.\r\n    -   To determine the duration to the jump peak height in this scenario, we first construct two instances of one of the basic equations of motion--one for the former part of the ascent, with the slow-ascent gravity, and one for the latter part of the ascent, with the fast-fall gravity. We then use algebra to substitute the equations and solve for the duration.\r\n\r\n#### Calculating the horizontal steps in an edge\r\n\r\n-   If we decide whether a surface could be within reach, we then check for possible collisions between the origin and destination.\r\n    -   To do this, we simulate frame-by-frame motion using the same physics timestep and the same movement-update function calls that would be used when running the game normally. We then check for any collisions between each frame.\r\n-   If we detect a collision, then we define two possible \"constraints\"--one for each end of the collided surface.\r\n    -   In order to make it around this intermediate surface, we know the player must pass around one of the ends of this surface.\r\n    -   These constraints we calculate represent the minimum required deviation from the player's original path.\r\n-   We then recursively check whether the player could move to and from each of the constraints.\r\n    -   We keep the original vertical step and overall duration the same.\r\n    -   We can use that to calculate the time and vertical state that must be used for the constraint.\r\n    -   Then we only really consider whether the horizontal movement could be valid within the the given time limit.\r\n-   If so, we concatenate and return the horizontal steps required to reach the constraint from the original starting position and the horizontal steps required to reach the original destination from the constraint.\r\n\r\n#### Backtracking to consider a higher max jump height\r\n\r\n-   Sometimes, a constraint may be out of reach, when we're calculating horizontal steps, given the current step's starting position and velocity.\r\n-   However, maybe the constraint could be within reach, if we had originally jumped a little higher.\r\n-   To account for this, we backtrack to the start of the overall movement traversal and consider whether a higher jump could reach the constraint.\r\n    -   The destination constraint is first updated to support a new jump height that would allow for a previously-out-of-reach intermediate constraint to also be reached.\r\n    -   Then all steps are re-calculated from the start of the movement, while considering the new destination state.\r\n-   If it could, we return that result instead.\r\n\r\n#### Constraint calculations\r\n\r\n-   We calculate constraints before steps.\r\n    -   We calculate a lot of state to store on them, and then depend on this state during step calculation.\r\n    -   Some of this state includes:\r\n        -   The time for passing through the constraint (corresponding to the overall jump height and edge duration).\r\n        -   The horizontal direction of movement through the constraint (according to the direction of travel from the previous constraint or according to the direction of the surface).\r\n        -   The min and max possible x-velocity when the movement passes through this constraint.\r\n            -   With a higher speed through a constraint, we could reach further for the next constraint, or we could be stuck overshooting the next constraint. So it's useful to calculate the range of possible horizontal velocities through a constraint.\r\n        -   The actual x-velocity for movement through the constraint is calculated later when calculating the cooresponding movement step.\r\n            -   We typically try to use an x-velocity that will minimize speed through the constraint, while still satisfying the horizontal step displacement and the constraint's min\/max limitations.\r\n-   Here's the sequence of events for constraint calculations:\r\n    -   Start by calculating origin and destination constraints.\r\n        -   For the origin constraint, min, max, and actual x-velocity are all zero.\r\n        -   For the destination constraint, min and max are assigned according to how acceleration can be applied during the step (e.g., at the start or at the end of the interval).\r\n    -   Then, during step calculation traversal, when a new intermediate constraint is created, its min and max x-velocity are assigned according to both the min and max x-velocity of the following constraint and the actual displacement and duration of the step from the new constraint to the next constraint.\r\n    -   Intermediate constraints are calculated with pre-order tree traversal.\r\n      -   This poses a small problem:\r\n        -   The calculation of a constraint depends on the accuracy of the min\/max x-velocity of it's next constraint.\r\n        -   However, the min\/max x-velocity of the next constraint could need to be updated if it in turn has a new next constraint later on.\r\n        -   Additionally, a new constraint could be created later on that would become the new next constraint instead of the old next constraint.\r\n        -   To ameliorate this problem, everytime a new constraint is created, we update its immediate neighbor constraints.\r\n        -   These updates do not solve all cases, since we may in turn need to update the min\/max x-velocities and movement sign for all other constraints. And these updates could then result in the addition\/removal of other intermediate constraints. But we have found that these two updates are enough for most cases. If we detect that a neigbor constraint would be invalidated during an update, we abandon the edge calculation, which could result in a false-negative result.\r\n    -   Steps are calculated with in-order tree traversal (i.e., in the same order they'd be executed when moving from origin to destination).\r\n\r\n#### Fake constraints\r\n\r\n-   When calcuting steps to navigate around a collision with a ceiling or floor surface, sometimes one of the two possible constraints is what we call \"fake\".\r\n-   A fake constraint corresponds to the left side of the floor\/ceiling surface when movement from the previous constraint is rightward (or to the right side when movement is leftward).\r\n-   In this case, movement will need to go around both the floor\/ceiling as well as its adjacent wall surface.\r\n-   The final movement trajectory should not end-up moving through the fake constraint.\r\n-   The actual constraint that the final movement should move through, is instead the \"real\" constraint that cooresponds to the far edge of this adjacent wall surface.\r\n-   So, when we find a fake constraint, we immediately replace it with its adjacent real constraint.\r\n-   Example scenario:\r\n  -   Origin is constraint #0, Destination is constraint #3\r\n  -   Assume we are jumping from a low-left platform to a high-right platform, and there is an intermediate block in the way.\r\n  -   Our first step attempt hits the underside of the block, so we try constraints on either side.\r\n  -   After trying the left-hand constraint (#1), we then hit the left side of the block. So we then try a top-side constraint (#2).\r\n      -   (Bottom-side fails the surface-already-encountered check).\r\n  -   After going through this new left-side (right-wall), top-side constraint (#2), we can successfully reach the destination.\r\n  -   With the resulting scenario, we shouldn't actually move through both of the intermediate constraints (#1 and #2). We should should instead skip the first intermediate constraint (#1) and go straight from the origin to the second intermediate constraint (#2).\r\n\r\nTODO: screenshot of example scenario\r\n\r\n#### Example jump-movement cases that aren't currently covered\r\n\r\n-   A single horizontal step that needs multiple different sideways-movement instructions (i.e., accelerating to both one side and then the other in the same jump):\r\n    -   For example, backward acceleration in order to not overshoot the end position as well as forward acceleration to then have enough step-end x velocity in order to reach the following constraint for the next step.\r\n\r\n#### Collision calculation madness\r\n\r\n**tl;dr**: Godot's collision-detection engine is very broken. We try to make it work for our\r\npathfinding, but there are still many false negatives and rough edges.\r\n\r\nHere's a direct quote from a comment in Godot's underlying collision-calculation logic:\r\n\r\n> give me back regular physics engine logic\r\n> this is madness\r\n> and most people using this function will think\r\n> what it does is simpler than using physics\r\n> this took about a week to get right..\r\n> but is it right? who knows at this point..\r\n\r\n(https:\/\/github.com\/godotengine\/godot\/blob\/a7f49ac9a107820a62677ee3fb49d38982a25165\/servers\/physics_2d\/space_2d_sw.cpp#L692)\r\n\r\nSome known limitations and rough edges include:\r\n-   TODO\r\n\r\n### Navigator: Using the platform graph to move from A to B\r\n\r\nOnce the platform graph has been parsed, finding and moving along a path through the graph is relatively straight-forward. The sequence of events looks like the following:\r\n\r\n-   Given a target point to navigate towards and the player's current position.\r\n-   Find the closest point along the closest surface to the target point.\r\n-   Use A* search to find a path through the graph from the origin to the destination.\r\n    -   We can use distance or duration as the edge weights.\r\n-   Execute playback of the instruction set for each edge of the path, in sequence.\r\n\r\n#### Edge instructions playback\r\n\r\nWhen we create the edges, we represent the movement trajectories according to the sequence of instructions that would produce the trajectory. Each instruction is simply represented by an ID for the relevant input key, whether the key is being pressed or released, and the time. The player movement system can then handle these input key events in the same way as actual human-triggered input key events.\r\n\r\n## Annotators\r\n\r\nWe include a large collection of annotators that are useful for visually debugging calculation of the platform graph. Some of the more note-worthy annotators include:\r\n-   `CollisionCalculationAnnotator`: \r\n-   `EdgeCalculationAnnotator`: \r\n-   `EdgeCalculationTreeViewAnnotator`: \r\n-   `InterSurfaceEdgesAnnotator`: \r\n    -   When viewing edge calculation trajectories, each edge is shown with two trajectories:\r\n        -   The darker trajectory represents positions as calculated from _continuous equations of motion_.\r\n        -   The lighter trajectory represents positions as calculated from _simulating movement over distrete time steps_.\r\n-   `NavigatorAnnotator`: \r\n-   `PlayerAnnotator`: \r\n-   `PlayerRecentMovementAnnotator`: \r\n-   `RulerAnnotator`: \r\n-   `SurfacesAnnotator`: \r\nTODO: Include a brief description of each annotator.\r\n"
}